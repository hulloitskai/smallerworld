#!/usr/bin/env node
// Print Client - Tails recent posts from a SmallerWorld space
//
// Generated by AI (Claude)

import { exec } from "node:child_process";
import { mkdir } from "node:fs/promises";
import { dirname, join } from "node:path";
import { fileURLToPath } from "node:url";
import { promisify } from "node:util";
import { chromium } from "playwright";
import meow from "meow";

const execAsync = promisify(exec);

const __dirname = dirname(fileURLToPath(import.meta.url));
const PROJECT_ROOT = join(__dirname, "..");
const PRINTS_DIR = join(PROJECT_ROOT, "tmp", "printclient", "prints");

const PRODUCTION_URL = "https://smallerworld.club";
const LOCALHOST_URL = "http://localhost:3000";
const POLL_INTERVAL_MS = 1000;

const cli = meow(
  `Usage
    $ bin/printclient <space-id>

  Arguments
    space-id    The ID of the space to monitor

  Options
    --interval, -i     Polling interval in milliseconds (default: 1000)
    --printer, -p      Printer name to send PDFs to (e.g., Printer_POS_80)
    --localhost, -l    Use localhost:3000 instead of smallerworld.club
    --include-latest   Also print the latest post from initial sync
    --debug, -d        Enable debug logging

  Examples
    $ bin/printclient abc123
    $ bin/printclient abc123 --printer Printer_POS_80
    $ bin/printclient abc123 --include-latest --localhost --debug
    $ bin/printclient abc123 --interval 2000`,
  {
    importMeta: import.meta,
    autoHelp: true,
    autoVersion: true,
    flags: {
      interval: {
        type: "number",
        shortFlag: "i",
        default: POLL_INTERVAL_MS,
      },
      printer: {
        type: "string",
        shortFlag: "p",
      },
      localhost: {
        type: "boolean",
        shortFlag: "l",
        default: false,
      },
      includeLatest: {
        type: "boolean",
        default: false,
      },
      debug: {
        type: "boolean",
        shortFlag: "d",
        default: false,
      },
    },
  },
);

const BASE_URL = cli.flags.localhost ? LOCALHOST_URL : PRODUCTION_URL;

const debug = (...args) => {
  if (cli.flags.debug) {
    console.log("[debug]", ...args);
  }
};

/**
 * Fetches posts from the space endpoint
 * @param {string} spaceId
 * @returns {Promise<Array<{id: string, author_name: string, snippet: string, created_at: string, type: string}>>}
 */
const fetchPosts = async spaceId => {
  const url = `${BASE_URL}/spaces/${spaceId}/posts.json`;
  debug(`Fetching: ${url}`);
  const response = await fetch(url, {
    headers: {
      Accept: "application/json",
    },
  });

  debug(`Response status: ${response.status}`);

  if (!response.ok) {
    const text = await response.text();
    debug(`Response body: ${text.slice(0, 500)}`);
    throw new Error(
      `Failed to fetch posts: ${response.status} ${response.statusText}`,
    );
  }

  const data = await response.json();
  debug(`Got ${data.posts?.length ?? 0} posts`);
  return data.posts;
};

/**
 * Formats a post for printing to stdout
 * @param {{id: string, author_name: string, snippet: string, created_at: string, type: string}} post
 * @returns {string}
 */
const formatPost = post => {
  const timestamp = new Date(post.created_at).toLocaleString();
  const author = post.author_name || "Anonymous";
  const content = post.snippet.split("\n")[0];
  return `[${timestamp}] ${author} ${content}`;
};

const firstLineOf = text => {
  return text.split("\n")[0];
};

/**
 * Prints a post to PDF using Playwright
 * @param {{id: string}} post
 */
const printPostToPdf = async post => {
  const printUrl = `${BASE_URL}/posts/${post.id}/print`;
  const outputPath = join(PRINTS_DIR, `${post.id}.pdf`);

  debug(`Opening browser for PDF: ${printUrl}`);

  const browser = await chromium.launch({ channel: "chromium" });
  try {
    const page = await browser.newPage();
    await page.goto(printUrl, { waitUntil: "networkidle" });

    // Wait for page to fully render
    await page.waitForLoadState("domcontentloaded");

    // Wait for React to hydrate - look for the PostCard content
    const postCardSelector = ".PostCard";
    await page.waitForSelector(postCardSelector, {
      timeout: 10_000,
    });

    // Wait for web fonts to load
    await page.waitForFunction(() => document.fonts.ready);

    // Measure PostCard dimensions (after zoom applied)
    const { width: contentWidth, height: contentHeight } = await page.evaluate(
      selector => {
        const el = document.querySelector(selector);
        if (!el) {
          throw new Error("PostCard element not found");
        }
        const rect = el.getBoundingClientRect();
        return {
          width: Math.ceil(rect.width),
          height: Math.ceil(rect.height),
        };
      },
      postCardSelector,
    );
    debug(`PostCard size: ${contentWidth}x${contentHeight}px`);

    // Ensure output directory exists
    await mkdir(PRINTS_DIR, { recursive: true });

    // Force screen media (not print) to preserve styles
    await page.emulateMedia({ media: "screen" });

    // Print to PDF with dynamic dimensions
    await page.pdf({
      path: outputPath,
      width: `${contentWidth}px`,
      height: `${contentHeight}px`,
      printBackground: true,
    });

    debug(`Saved PDF to: ${outputPath}`);
    console.log(`[pdf] ${outputPath}`);

    return { path: outputPath, width: contentWidth, height: contentHeight };
  } finally {
    await browser.close();
  }
};

/**
 * Sends a PDF to a system printer using lp command
 * @param {string} pdfPath
 * @param {string} printerName
 * @param {number} widthPx - Width in pixels for custom paper size
 * @param {number} heightPx - Height in pixels for custom paper size
 */
const printToSystemPrinter = async (
  pdfPath,
  printerName,
  widthPx,
  heightPx,
) => {
  // Convert pixels to mm (96 DPI: 1 inch = 25.4mm)
  const widthMm = Math.ceil((widthPx * 25.4) / 96);
  const heightMm = Math.ceil((heightPx * 25.4) / 96);

  debug(`Printing ${pdfPath} to ${printerName} (${widthMm}x${heightMm}mm)`);
  try {
    // Use custom media size to match the dynamic PDF dimensions
    const cmd = `lp -d "${printerName}" -o media=Custom.${widthMm}x${heightMm}mm -o fit-to-page "${pdfPath}"`;
    debug(`Command: ${cmd}`);
    await execAsync(cmd);
    console.log(`[print] Sent to ${printerName}`);
  } catch (error) {
    console.error(`[print] Error: ${error.message}`);
  }
};

/**
 * Main function
 */
const main = async () => {
  const [spaceId] = cli.input;
  const { interval, printer, includeLatest } = cli.flags;

  if (!spaceId) {
    cli.showHelp(1);
  }

  const pollInterval = interval;
  console.log(`Starting PrintClient for space: ${spaceId}`);
  console.log(
    `Polling ${BASE_URL}/spaces/${spaceId}/posts every ${pollInterval}ms`,
  );
  if (printer) {
    console.log(`Printing to: ${printer}`);
  }
  console.log("---");

  const seenPostIds = new Set();
  let latestPostDate = null;

  // Initial fetch to establish baseline
  try {
    const posts = await fetchPosts(spaceId);

    for (const post of posts) {
      seenPostIds.add(post.id);
    }

    // Track the latest post date (first post is newest)
    if (posts.length > 0) {
      latestPostDate = new Date(posts[0].created_at);
      debug(`Latest post date: ${latestPostDate.toISOString()}`);

      // Optionally print the latest post
      if (includeLatest) {
        const latestPost = posts[0];
        console.log(formatPost(latestPost));
        const {
          path: pdfPath,
          width,
          height,
        } = await printPostToPdf(latestPost);
        if (printer) {
          await printToSystemPrinter(pdfPath, printer, width, height);
        }
      }
    }

    console.log(
      `Initial sync complete. Tracking ${seenPostIds.size} existing posts.`,
    );
    console.log("Watching for new posts...");
    console.log("---");
  } catch (error) {
    console.error(`Error during initial fetch: ${error.message}`);
    process.exit(1);
  }

  // Start polling
  let pollCount = 0;
  const poll = setInterval(async () => {
    pollCount++;
    debug(`Poll #${pollCount}, seen ${seenPostIds.size} posts`);
    try {
      const posts = await fetchPosts(spaceId);

      if (posts.length === 0) {
        debug(`No posts returned`);
        return;
      }

      // Find posts we haven't seen before AND are newer than latest seen date
      const newPosts = posts.filter(post => {
        if (seenPostIds.has(post.id)) {
          return false;
        }
        // Only include posts newer than the latest post date we've seen
        if (latestPostDate) {
          const postDate = new Date(post.created_at);
          return postDate > latestPostDate;
        }
        return true;
      });

      // Mark as seen IMMEDIATELY to prevent duplicates from overlapping polls
      // (PDF generation is slow, polls happen every second)
      for (const post of newPosts) {
        seenPostIds.add(post.id);
        // Update latest post date if this is newer
        const postDate = new Date(post.created_at);
        if (!latestPostDate || postDate > latestPostDate) {
          latestPostDate = postDate;
          debug(`Updated latest post date: ${latestPostDate.toISOString()}`);
        }
      }

      debug(`Found ${newPosts.length} new posts`);

      // Print new posts in chronological order (oldest first)
      if (newPosts.length > 0) {
        newPosts.reverse();
        for (const post of newPosts) {
          console.log(formatPost(post));
          const { path: pdfPath, width, height } = await printPostToPdf(post);
          if (printer) {
            await printToSystemPrinter(pdfPath, printer, width, height);
          }
        }
      }
    } catch (error) {
      console.error(`Error polling: ${error.message}`);
      // Don't exit, keep trying
    }
  }, pollInterval);

  // Handle graceful shutdown
  const shutdown = () => {
    console.log("\nShutting down...");
    clearInterval(poll);
    process.exit(0);
  };

  process.on("SIGINT", shutdown);
  process.on("SIGTERM", shutdown);
};

main();
