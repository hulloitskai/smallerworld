# Cursor Rules

## Code Formatting

**Before committing code changes, run:**

```bash
bin/cursor_agent_format_code
```

**This script automatically handles environment setup and runs all formatting tools with proper error handling.**

### Version Consistency
- The formatting script uses project dependencies (`npm exec`) instead of global versions to ensure consistency with CI
- If experiencing formatting differences between local and CI:
  1. Check that your local Node.js version matches CI
  2. Run `npm ci` to ensure exact dependency versions
  3. Set `USE_PROJECT_DEPS=false bin/cursor_agent_format_code` only for debugging
- **Never mix global and project versions** of formatting tools in the same workflow

## Code Simplicity

### Prefer Direct Logic Over Premature Optimization

- Avoid unnecessary `useMemo`, `useCallback`, or complex abstractions when simple inline logic suffices
- Example: Instead of memoizing a simple boolean calculation, use it directly in props:

  ```tsx
  // ❌ Unnecessary complexity
  const waitingForInstallEvent = useMemo(() => {
    if (!browserDetection) return false;
    return shouldWaitForInstallEvent(browserDetection) && !install;
  }, [browserDetection, install]);

  // ✅ Simple and direct
  loading={installing || (browserDetection && shouldWaitForInstallEvent(browserDetection) && !install)}
  ```

- Prioritize readability and maintainability over micro-optimizations unless performance issues are measured

### Browser Detection Specifics

- Android devices may not always be detected as "Chrome" browser but can still support `beforeinstallprompt`
- When checking for PWA install support, check both `result.browser.is("Chrome")` OR `result.os.is("Android")`

## Project Structure Guidelines

### `docs/` Directory

- **Purpose**: Documentation for debugging findings, technical decisions, and architectural notes
- **Naming**: Use "Title Casing With Spaces.md" for readability
- **Content**: Comprehensive technical documentation that helps future developers understand complex issues, fixes, and decisions
- **When to create**: After solving complex bugs, implementing significant features, or making architectural decisions

### `bin/` Directory

- **Purpose**: Executable scripts for cursor agents and project automation
- **For cursor agents**: `bin/cursor_agent_format_code` - Automatic code formatting
- **Future agent scripts**: Place new cursor agent-specific executables here
- **Usage**: Always use relative path (e.g., `bin/cursor_agent_format_code`, not `./bin/cursor_agent_format_code`)
- **Permissions**: Scripts should be executable (`chmod +x`)

## Generated Files - DO NOT MODIFY

**NEVER modify these generated files:**

- `typings/generated/auto-import.d.ts` (unplugin-auto-import generated)
- `app/helpers/routes/generated/**/*.ts` (JsFromRoutes generated)
- `db/schema.rb` (Rails database schema)
- `sorbet/rbi/dsl/**/*.rbi` (Sorbet RBI files)
- Any file with `*generated*` in the path
- Any file with comments indicating it's auto-generated

**If you need to modify functionality related to these files:**

- For auto-imports: Update the import configuration in `vite.config.ts`
- For routes: Modify the Rails routes in `config/routes.rb`
- For database: Create a new migration instead of editing schema directly
- For Sorbet: Let the tools regenerate the files

## AI Generation Headers

- When generating new files or substantially modifying existing files, add a header comment indicating:
  - Model name that generated the code (e.g., "Claude Sonnet 4")
  - Last modified timestamp in UTC format
  - Note that the code was AI-generated and may require human review
- Use this format:
  ```
  /**
   * Generated by: [Model Name]
   * Last modified: [YYYY-MM-DD HH:mm:ss UTC]
   *
   * This code was AI-generated and may require human review and testing.
   */
  ```

## Import Rules

- Don't auto-add imports if they are available in the auto-import types file (`typings/generated/auto-import.d.ts`)
- Check the global declarations in auto-import.d.ts before suggesting or adding imports for commonly used utilities and components

## TypeScript Array Access Rules

- When doing direct array access in the context of an algorithm, use non-null TypeScript assertion like `arr[i]!` as needed
- Apply non-null assertions for array access when the algorithm logic guarantees the element exists but TypeScript cannot infer this

## Function Declaration Style

- Use arrow function expressions (`const functionName = () => {}`) instead of function declarations (`function functionName() {}`)
- This applies to all functions including exported functions, utility functions, and event handlers
- Prefer `const` declarations for consistency with the codebase style

## Component Patterns

### Component Structure

```tsx
// Import external libraries first
import { Button, Stack } from "@mantine/core";
import { useModals } from "@mantine/modals";

// Import icons from unplugin-icons
import IconName from "~icons/heroicons/icon-name-20-solid";

// Import internal types and helpers
import { type ComponentProps } from "~/types";
import { helperFunction } from "~/helpers/domain";

// Import other components
import SomeComponent from "./SomeComponent";

// Import styles last
import classes from "./ComponentName.module.css";

// Define props interface
export interface ComponentNameProps {
  // props definition
}

// Component implementation using arrow function
const ComponentName: FC<ComponentNameProps> = ({ prop1, prop2 }) => {
  // Component logic
  return <div className={classes.wrapper}>{/* Component JSX */}</div>;
};

export default ComponentName;
```

### Page Components with Layouts

- Pages define their own layout using `PageName.layout = page => <Layout>{page}</Layout>`
- Use `PageComponent<PropsType>` type for page components
- Include props interface extending `SharedPageProps`

## Data Fetching Patterns

### SWR Usage

```tsx
const { data, error, mutate } = useRouteSWR<ResponseType>(
  routes.endpoint.path(),
  {
    descriptor: "descriptive name for debugging",
    keepPreviousData: true,
  },
);
```

### Mutations

```tsx
const { trigger } = useRouteMutation<ResponseType>(routes.endpoint.path(), {
  descriptor: "action description",
});
```

## URL Handling Conventions

### usePage() URL Extraction

- **Pages**: Use `pageUrl` for clarity when dealing with multiple URLs
  ```tsx
  const { url: pageUrl } = usePage();
  ```
- **Helpers**: Use `url` when context is clear and focused
  ```tsx
  const { url } = usePage();
  ```
- **Components**: Use `pageUrl` when dealing with multiple URLs for clarity

## Authentication & Authorization

- **Current User**: `useCurrentUser()` for authenticated user
- **Current Friend**: `useCurrentFriend()` for friend access tokens
- **Admin Check**: `useIsAdmin()` for admin-only features
- **Action Policy**: Authorization using Action Policy gem (not Pundit)
- Dual authentication system supporting both user sessions and friend tokens
- Handle `ActionPolicy::Unauthorized` exceptions in controllers

## PWA & Mobile Patterns

- **PWA Detection**: `usePWA()` hook for standalone mode detection
- **Mobile Responsive**: `useIsMobileSize()` for responsive behavior
- **Service Worker**: Custom navigation handling for PWA
- **Install Prompts**: App-specific install flow components
- **Offline Support**: Service worker caching strategies
- **PWA Scope Management**: Use `pwa_scope` query parameter to maintain PWA context during navigation; `useOutOfPWAScope()` relies on this parameter for proper scope detection
- **PWA Navigation**: Use `PWAScopedLink` component for internal navigation; for `location.href` redirects, preserve query parameters using `queryParamsFromPath(pageUrl)` and pass to routes as `{ query }`

## Auto-Import System

The application uses extensive auto-imports for:

- **Mantine Components**: `Button`, `Stack`, `Text`, etc.
- **Icons**: Custom icon system with consistent naming
- **Utilities**: Lodash-es functions, date utilities, formatting helpers
- **Hooks**: React hooks, Mantine hooks, custom hooks
- **Routing**: Inertia router, custom route helpers
- **Common Types**: Exported in global scope

Check `typings/generated/auto-import.d.ts` before adding imports.

## Real-time Features

- **ActionCable**: Use `useSubscription` hook for real-time updates
- **WebPush**: Notification system with `useWebPush` hook
- **Live Updates**: Automatic data revalidation on window focus
