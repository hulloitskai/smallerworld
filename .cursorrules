# Cursor Rules

## AI Generation Headers

- When generating new files or substantially modifying existing files, add a header comment indicating:
  - Model name that generated the code (e.g., "Claude Sonnet 4")
  - Last modified timestamp in UTC format
  - Note that the code was AI-generated and may require human review
- Use this format:
  ```
  /**
   * Generated by: [Model Name]
   * Last modified: [YYYY-MM-DD HH:mm:ss UTC]
   *
   * This code was AI-generated and may require human review and testing.
   */
  ```

## Import Rules

- Don't auto-add imports if they are available in the auto-import types file (`typings/generated/auto-import.d.ts`)
- Check the global declarations in auto-import.d.ts before suggesting or adding imports for commonly used utilities and components

## TypeScript Array Access Rules

- When doing direct array access in the context of an algorithm, use non-null TypeScript assertion like `arr[i]!` as needed
- Apply non-null assertions for array access when the algorithm logic guarantees the element exists but TypeScript cannot infer this

## Function Declaration Style

- Use arrow function expressions (`const functionName = () => {}`) instead of function declarations (`function functionName() {}`)
- This applies to all functions including exported functions, utility functions, and event handlers
- Prefer `const` declarations for consistency with the codebase style

## Component Patterns

### Component Structure

```tsx
// Import external libraries first
import { Button, Stack } from "@mantine/core";
import { useModals } from "@mantine/modals";

// Import icons from unplugin-icons
import IconName from "~icons/heroicons/icon-name-20-solid";

// Import internal types and helpers
import { type ComponentProps } from "~/types";
import { helperFunction } from "~/helpers/domain";

// Import other components
import SomeComponent from "./SomeComponent";

// Import styles last
import classes from "./ComponentName.module.css";

// Define props interface
export interface ComponentNameProps {
  // props definition
}

// Component implementation using arrow function
const ComponentName: FC<ComponentNameProps> = ({ prop1, prop2 }) => {
  // Component logic
  return <div className={classes.wrapper}>{/* Component JSX */}</div>;
};

export default ComponentName;
```

### Page Components with Layouts

- Pages define their own layout using `PageName.layout = page => <Layout>{page}</Layout>`
- Use `PageComponent<PropsType>` type for page components
- Include props interface extending `SharedPageProps`

## Data Fetching Patterns

### SWR Usage

```tsx
const { data, error, mutate } = useRouteSWR<ResponseType>(
  routes.endpoint.path(),
  {
    descriptor: "descriptive name for debugging",
    keepPreviousData: true,
  },
);
```

### Mutations

```tsx
const { trigger } = useRouteMutation<ResponseType>(routes.endpoint.path(), {
  descriptor: "action description",
});
```

## Authentication & Authorization

- **Current User**: `useCurrentUser()` for authenticated user
- **Current Friend**: `useCurrentFriend()` for friend access tokens
- **Admin Check**: `useIsAdmin()` for admin-only features
- **Action Policy**: Authorization using Action Policy gem (not Pundit)
- Dual authentication system supporting both user sessions and friend tokens
- Handle `ActionPolicy::Unauthorized` exceptions in controllers

## PWA & Mobile Patterns

- **PWA Detection**: `usePWA()` hook for standalone mode detection
- **Mobile Responsive**: `useIsMobileSize()` for responsive behavior
- **Service Worker**: Custom navigation handling for PWA
- **Install Prompts**: App-specific install flow components
- **Offline Support**: Service worker caching strategies
- **PWA Scope Management**: Use `pwa_scope` query parameter to maintain PWA context during navigation; `useOutOfPWAScope()` relies on this parameter for proper scope detection
- **PWA Navigation**: Use `PWAScopedLink` component for internal navigation that preserves PWA scope; for `location.href` redirects, create helper functions following the pattern from `PWAScopedLink.tsx`:
  ```typescript
  const addPWAScopeToHref = (href: string): string => {
    const { pwa_scope: previousScope } = queryParamsFromPath(location.href);
    if (previousScope) {
      return addScopeToHref(href, previousScope);
    }
    const currentScope = getPWAScope();
    if (currentScope) {
      return addScopeToHref(href, currentScope);
    }
    return href;
  };
  
  const addScopeToHref = (href: string, scope: string): string => {
    const url = new URL(href, location.origin);
    url.searchParams.set("pwa_scope", scope);
    return url.toString();
  };
  ```

## Auto-Import System

The application uses extensive auto-imports for:

- **Mantine Components**: `Button`, `Stack`, `Text`, etc.
- **Icons**: Custom icon system with consistent naming
- **Utilities**: Lodash-es functions, date utilities, formatting helpers
- **Hooks**: React hooks, Mantine hooks, custom hooks
- **Routing**: Inertia router, custom route helpers
- **Common Types**: Exported in global scope

Check `typings/generated/auto-import.d.ts` before adding imports.

## Real-time Features

- **ActionCable**: Use `useSubscription` hook for real-time updates
- **WebPush**: Notification system with `useWebPush` hook
- **Live Updates**: Automatic data revalidation on window focus
