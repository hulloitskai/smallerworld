/**
 * NEKO SPRITE COMPONENT
 *
 * This file implements a React component that renders an animated cat (neko) sprite.
 * The component uses a sprite sheet image and CSS background positioning to display
 * different animation frames. It supports multiple animation types (defined in the
 * neko helper) with configurable animation speeds.
 *
 * Key features:
 * - Automatic frame progression using requestAnimationFrame
 * - Configurable animation speed multiplier
 * - Support for multiple animation types (idle, walking, running, etc.)
 * - Proper cleanup of animation timers
 * - Accessibility considerations (aria-hidden)
 *
 * The component relies on sprite data and utilities from ~/helpers/neko for
 * animation definitions and background positioning calculations.
 *
 * Generated by: Claude Sonnet 4
 * Last modified: 2025-01-09 10:45:00 UTC
 *
 * This code was AI-generated and may require human review and testing.
 */

import spriteSrc from "~/assets/images/neko-sprite.gif";

import {
  type Animation,
  getSpriteBackgroundPosition,
  NEKO_SIZE,
  SPRITE_SETS,
} from "~/helpers/neko";

export interface NekoProps extends BoxProps {
  /** Current animation name */
  animation: Animation;
  /** Animation speed multiplier (1.0 = normal speed, 2.0 = 2x faster, 0.5 = half speed) */
  animationSpeed?: number;
}

const DEFAULT_ANIMATION_INTERVAL = 200; // milliseconds between frame changes

/**
 * Neko component that renders a cat sprite with automatic frame management
 */
const Neko: FC<NekoProps> = ({
  animation,
  animationSpeed = 1,
  className,
  style,
  ...otherProps
}) => {
  const [currentFrame, setCurrentFrame] = useState(0);
  const animationRef = useRef<number>();
  const lastFrameTimeRef = useRef<number>();
  const prevAnimationRef = useRef<Animation>();

  // Calculate animation interval based on speed multiplier
  const animationInterval = DEFAULT_ANIMATION_INTERVAL / animationSpeed;

  // Reset frame when animation changes
  useEffect(() => {
    if (prevAnimationRef.current !== animation) {
      setCurrentFrame(0);
      prevAnimationRef.current = animation;
    }
  }, [animation]);

  // Handle frame progression
  useEffect(() => {
    const currentAnimation = SPRITE_SETS[animation];

    // Don't animate single-frame animations
    if (!currentAnimation || currentAnimation.length <= 1) {
      return;
    }

    const animate = (timestamp: number): void => {
      if (!lastFrameTimeRef.current) {
        lastFrameTimeRef.current = timestamp;
      }

      if (timestamp - lastFrameTimeRef.current >= animationInterval) {
        setCurrentFrame(prev => (prev + 1) % currentAnimation.length);
        lastFrameTimeRef.current = timestamp;
      }

      animationRef.current = requestAnimationFrame(animate);
    };

    animationRef.current = requestAnimationFrame(animate);

    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
      lastFrameTimeRef.current = undefined;
    };
  }, [animation, animationInterval]);

  const backgroundPosition = useMemo(
    () => getSpriteBackgroundPosition(animation, currentFrame),
    [animation, currentFrame],
  );

  return (
    <Box
      className={cn("Neko", className)}
      w={NEKO_SIZE}
      h={NEKO_SIZE}
      style={[
        {
          backgroundImage: `url(${spriteSrc})`,
          backgroundPosition,
          backgroundRepeat: "no-repeat",
        },
        style,
      ]}
      aria-hidden="true"
      {...otherProps}
    />
  );
};

export default Neko;
