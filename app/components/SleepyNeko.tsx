/**
 * Generated by: Claude Sonnet 4
 * Last modified: 2025-01-09 10:45:00 UTC
 *
 * This code was AI-generated and may require human review and testing.
 */

import { useWindowEvent } from "@mantine/hooks";

import Neko, { type NekoProps } from "~/components/Neko";

export interface SleepyNekoProps
  extends Omit<NekoProps, "animation" | "animationSpeed"> {}

type NekoState = "idle" | "alert" | "scratch-self" | "tired" | "sleeping";

interface StateConfig {
  duration?: number; // optional for indefinite states
  nextState?: NekoState;
  animationSpeed?: number; // defaults to unset, but 0.5 for sleeping
}

const STATE_CONFIGS: Record<NekoState, StateConfig> = {
  idle: {},
  "scratch-self": {
    duration: 2000,
    nextState: "idle",
  },
  tired: {
    duration: 1000,
    nextState: "sleeping",
  },
  alert: {
    duration: 1000,
    nextState: "idle",
  },
  sleeping: {
    animationSpeed: 0.5,
  },
};
const TIREDNESS_DELAY = 10000; // 10 seconds
const SCRATCH_INTERVAL_RANGE: [number, number] = [4000, 7000]; // 4-7 seconds

/**
 * SleepyNeko component that manages behavioral states and animations
 */
const SleepyNeko: FC<SleepyNekoProps> = ({ ...otherProps }) => {
  const [state, setState] = useState<NekoState>("sleeping");

  const tirednessTimeoutRef = useRef<NodeJS.Timeout>();
  const actionTimeoutRef = useRef<NodeJS.Timeout>(); // For both state transitions and scratch scheduling

  // == Scratching
  const scheduleScratching = useCallback(() => {
    if (actionTimeoutRef.current) {
      return;
    }
    const delay = randomizedScratchingDelay();
    actionTimeoutRef.current = setTimeout(() => {
      setState(current => (current === "idle" ? "scratch-self" : current));
    }, delay);
  }, []);
  const resetScratching = useCallback(() => {
    const timeout = actionTimeoutRef.current;
    if (timeout) {
      clearTimeout(timeout);
    }
    actionTimeoutRef.current = undefined;
  }, []);

  // == Tiredness
  const scheduleTiredness = useCallback(() => {
    if (tirednessTimeoutRef.current) {
      return;
    }
    tirednessTimeoutRef.current = setTimeout(
      () => setState("tired"),
      TIREDNESS_DELAY,
    );
  }, []);
  const resetTiredness = useCallback(() => {
    const timeout = tirednessTimeoutRef.current;
    if (timeout) {
      clearTimeout(timeout);
    }
    tirednessTimeoutRef.current = undefined;
  }, []);

  // == Cleanup timeouts
  useEffect(() => {
    return () => {
      const actionTimeout = actionTimeoutRef.current;
      if (actionTimeout) {
        clearTimeout(actionTimeout);
      }

      const tirednessTimeout = tirednessTimeoutRef.current;
      if (tirednessTimeout) {
        clearTimeout(tirednessTimeout);
      }
    };
  }, []);

  // Handle state transitions
  useEffect(() => {
    const config = STATE_CONFIGS[state];

    // Prevent background behaviors for non-idle states
    if (state !== "idle" && state !== "scratch-self") {
      resetTiredness();
    }
    if (state !== "idle") {
      resetScratching();
    }

    // Set up automatic state transition
    if (config.duration && config.nextState) {
      const nextState = config.nextState; // Type narrowing
      if (actionTimeoutRef.current) {
        clearTimeout(actionTimeoutRef.current);
      }
      actionTimeoutRef.current = setTimeout(
        () => setState(nextState),
        config.duration,
      );
    } else if (actionTimeoutRef.current) {
      clearTimeout(actionTimeoutRef.current);
      actionTimeoutRef.current = undefined;
    }

    // Start background behaviors for idle state
    if (state === "idle") {
      scheduleTiredness();
      scheduleScratching();
    }
  }, [
    state,
    scheduleTiredness,
    scheduleScratching,
    resetTiredness,
    resetScratching,
  ]);

  // Handle window click events
  useWindowEvent("click", () => {
    setState("alert");
  });

  const { animationSpeed } = STATE_CONFIGS[state];
  return <Neko animation={state} {...{ animationSpeed }} {...otherProps} />;
};

export default SleepyNeko;

const randomizedScratchingDelay = (): number => {
  const [min, max] = SCRATCH_INTERVAL_RANGE;
  return Math.random() * (max - min) + min;
};
