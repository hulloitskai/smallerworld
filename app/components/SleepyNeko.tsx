/**
 * Generated by: Claude Sonnet 4
 * Last modified: 2025-01-09 10:45:00 UTC
 *
 * This code was AI-generated and may require human review and testing.
 */

import { useWindowEvent } from "@mantine/hooks";

import Neko, { type NekoProps } from "~/components/Neko";
import { type Animation } from "~/helpers/neko";

export interface SleepyNekoProps
  extends Omit<NekoProps, "animation" | "animationSpeed"> {}

type NekoState = "idle" | "alert" | "scratch-self" | "tired" | "sleeping";

interface StateConfig {
  duration: number | null; // null for indefinite states
  nextState: NekoState | null;
  allowsTiredness: boolean;
  allowsScratching: boolean;
}

// State machine configuration
const STATE_CONFIG: Record<NekoState, StateConfig> = {
  idle: {
    duration: null, // Indefinite
    nextState: null,
    allowsTiredness: true,
    allowsScratching: true,
  },
  "scratch-self": {
    duration: 2000,
    nextState: "idle",
    allowsTiredness: false, // Preserve tiredness timer
    allowsScratching: false,
  },
  tired: {
    duration: 1000,
    nextState: "sleeping",
    allowsTiredness: false,
    allowsScratching: false,
  },
  alert: {
    duration: 1000,
    nextState: "idle",
    allowsTiredness: false, // Reset tiredness
    allowsScratching: false,
  },
  sleeping: {
    duration: null, // Indefinite
    nextState: null,
    allowsTiredness: false,
    allowsScratching: false,
  },
} as const;

const TIREDNESS_DELAY = 10000; // 10 seconds
const SCRATCH_INTERVAL_RANGE: [number, number] = [5000, 8000]; // 5-8 seconds

/**
 * SleepyNeko component that manages behavioral states and animations
 */
const SleepyNeko: FC<SleepyNekoProps> = ({ ...otherProps }) => {
  const [state, setState] = useState<NekoState>("sleeping");

  const tirednessTimeoutRef = useRef<NodeJS.Timeout>();
  const actionTimeoutRef = useRef<NodeJS.Timeout>(); // For both state transitions and scratch scheduling

  // Schedule random scratching
  const scheduleScratching = useCallback(() => {
    const [min, max] = SCRATCH_INTERVAL_RANGE;
    const delay = Math.random() * (max - min) + min;

    if (actionTimeoutRef.current) {
      clearTimeout(actionTimeoutRef.current);
    }
    actionTimeoutRef.current = setTimeout(() => {
      setState(current => (current === "idle" ? "scratch-self" : current));
    }, delay);
  }, []);

  // Start tiredness timer
  const startTirednessTimer = useCallback(() => {
    if (tirednessTimeoutRef.current) {
      clearTimeout(tirednessTimeoutRef.current);
    }
    tirednessTimeoutRef.current = setTimeout(
      () => setState("tired"),
      TIREDNESS_DELAY,
    );
  }, []);

  // Handle state transitions
  useEffect(() => {
    const config = STATE_CONFIG[state];

    // Clear tiredness timeout for states that reset tiredness (not scratch-self)
    if (
      !config.allowsTiredness &&
      state !== "scratch-self" &&
      tirednessTimeoutRef.current
    ) {
      clearTimeout(tirednessTimeoutRef.current);
      tirednessTimeoutRef.current = undefined;
    }
    if (!config.allowsScratching && actionTimeoutRef.current) {
      clearTimeout(actionTimeoutRef.current);
      actionTimeoutRef.current = undefined;
    }

    // Set up automatic state transition
    if (config.duration && config.nextState) {
      const nextState = config.nextState; // Type narrowing
      if (actionTimeoutRef.current) {
        clearTimeout(actionTimeoutRef.current);
      }
      actionTimeoutRef.current = setTimeout(
        () => setState(nextState),
        config.duration,
      );
    } else if (actionTimeoutRef.current) {
      clearTimeout(actionTimeoutRef.current);
      actionTimeoutRef.current = undefined;
    }

    // Start background behaviors for idle state
    if (state === "idle") {
      // Only start tiredness timer if not already running
      if (!tirednessTimeoutRef.current) {
        startTirednessTimer();
      }
      scheduleScratching();
    }
  }, [state, startTirednessTimer, scheduleScratching]);

  // Cleanup timeouts on component unmount
  useEffect(() => {
    return () => {
      if (actionTimeoutRef.current) {
        clearTimeout(actionTimeoutRef.current);
      }
      if (tirednessTimeoutRef.current) {
        clearTimeout(tirednessTimeoutRef.current);
      }
    };
  }, []);

  // Handle window click events
  useWindowEvent("click", () => {
    setState("alert");
  });

  return <Neko animation={animationForState(state)} {...otherProps} />;
};

export default SleepyNeko;

/**
 * Map states to animations
 */
const animationForState = (state: NekoState): Animation => {
  switch (state) {
    case "idle":
      return "idle";
    case "alert":
      return "alert";
    case "scratch-self":
      return "scratch-self";
    case "tired":
      return "tired";
    case "sleeping":
      return "sleeping";
    default:
      return "idle";
  }
};
