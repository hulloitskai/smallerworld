/**
 * Generated by: Gemini 2.5 Pro
 * Last modified: 2024-07-31 21:42:00 UTC
 *
 * This code was AI-generated and may require human review and testing.
 *
 * @file Oneko - A cat that sits on elements.
 *
 * @summary This component renders a cat that sits on specified DOM elements.
 * It is adapted from the original oneko.js (https://github.com/adryd325/oneko.js).
 *
 * For performance, the cat's animation state (position, status, etc.) is managed in a `useRef`
 * object and updated outside of React's render cycle using `requestAnimationFrame`. This avoids
 * performance bottlenecks from frequent re-renders.
 *
 * The cat's behavior is controlled by a state machine (`CatStatus`) with the following states:
 * - `off-screen`: The cat is hidden and waiting for a target.
 * - `moving-to-target`: The cat has a target and is moving towards it.
 * - `sitting-on-target`: The cat has reached the target and is idle.
 * - `performing-idle-animation`: The cat is performing a random animation (e.g., sleeping).
 *
 * Element tracking is done via a CSS selector, and the cat will attempt to sit on the topmost
 * valid element in the viewport.
 */

import onekoSpriteSrc from "~/assets/images/oneko.gif";

import classes from "./Oneko.module.css";

interface Position {
  x: number;
  y: number;
}

interface SpriteCoordinate {
  x: number;
  y: number;
}

type SpriteAnimation = SpriteCoordinate[];

interface SpriteSets {
  idle: SpriteAnimation;
  alert: SpriteAnimation;
  scratchSelf: SpriteAnimation;
  scratchWallN: SpriteAnimation;
  scratchWallS: SpriteAnimation;
  scratchWallE: SpriteAnimation;
  scratchWallW: SpriteAnimation;
  tired: SpriteAnimation;
  sleeping: SpriteAnimation;
  N: SpriteAnimation;
  NE: SpriteAnimation;
  E: SpriteAnimation;
  SE: SpriteAnimation;
  S: SpriteAnimation;
  SW: SpriteAnimation;
  W: SpriteAnimation;
  NW: SpriteAnimation;
}

type IdleAnimationType =
  | "sleeping"
  | "scratchSelf"
  | "scratchWallN"
  | "scratchWallS"
  | "scratchWallE"
  | "scratchWallW"
  | null;

type CatStatus =
  | "off-screen"
  | "moving-to-target"
  | "sitting-on-target"
  | "performing-idle-animation";

interface OnekoState {
  element: HTMLDivElement;
  position: Position;
  targetPosition: Position;
  targetElement: HTMLElement | null;
  status: CatStatus;
  frameCount: number;
  idleTime: number;
  idleAnimation: IdleAnimationType;
  idleAnimationFrame: number;
  lastFrameTimestamp?: number;
  isRunning: boolean;
}

const SPRITE_SIZE = 32;
const ANIMATION_INTERVAL = 100; // milliseconds
const MAX_Z_INDEX = 2147483647;
const SPRITE_TOP_MARGIN = 20; // Minimum clearance from top of screen for target elements
const SPRITE_SETS: SpriteSets = {
  idle: [{ x: -3, y: -3 }],
  alert: [{ x: -7, y: -3 }],
  scratchSelf: [
    { x: -5, y: 0 },
    { x: -6, y: 0 },
    { x: -7, y: 0 },
  ],
  scratchWallN: [
    { x: 0, y: 0 },
    { x: 0, y: -1 },
  ],
  scratchWallS: [
    { x: -7, y: -1 },
    { x: -6, y: -2 },
  ],
  scratchWallE: [
    { x: -2, y: -2 },
    { x: -2, y: -3 },
  ],
  scratchWallW: [
    { x: -4, y: 0 },
    { x: -4, y: -1 },
  ],
  tired: [{ x: -3, y: -2 }],
  sleeping: [
    { x: -2, y: 0 },
    { x: -2, y: -1 },
  ],
  N: [
    { x: -1, y: -2 },
    { x: -1, y: -3 },
  ],
  NE: [
    { x: 0, y: -2 },
    { x: 0, y: -3 },
  ],
  E: [
    { x: -3, y: 0 },
    { x: -3, y: -1 },
  ],
  SE: [
    { x: -5, y: -1 },
    { x: -5, y: -2 },
  ],
  S: [
    { x: -6, y: -3 },
    { x: -7, y: -2 },
  ],
  SW: [
    { x: -5, y: -3 },
    { x: -6, y: -1 },
  ],
  W: [
    { x: -4, y: -2 },
    { x: -4, y: -3 },
  ],
  NW: [
    { x: -1, y: 0 },
    { x: -1, y: -1 },
  ],
};

export interface OnekoProps {
  /** Speed of the cat movement (default: 10) */
  speed?: number;
  /** CSS selector for elements to target (e.g., 'button', '.my-class', '[data-perch]') */
  targetSelector: string;
}

/**
 * Oneko component that renders a cat that finds and sits on specified elements
 */
const Oneko: FC<OnekoProps> = ({ speed = 10, targetSelector }) => {
  const animationFrameRef = useRef<number>();
  const stateRef = useRef<OnekoState>();
  const nekoRef = useRef<HTMLDivElement>(null);

  const startAnimation = useCallback(
    (state: OnekoState) => {
      const onAnimationFrame = (timestamp: number): void => {
        // Stop if element is removed from DOM or component unmounted
        if (!state.element.isConnected || !state.isRunning) {
          return;
        }

        state.lastFrameTimestamp ??= timestamp;

        // Limit to ~10 FPS
        if (timestamp - state.lastFrameTimestamp > ANIMATION_INTERVAL) {
          state.lastFrameTimestamp = timestamp;
          handleAnimationFrame(state, speed);
        }

        animationFrameRef.current = requestAnimationFrame(onAnimationFrame);
      };

      animationFrameRef.current = requestAnimationFrame(onAnimationFrame);
    },
    [speed],
  );

  const setupElementTracking = useCallback(
    (state: OnekoState) => {
      const findVisibleElements = (): HTMLElement[] => {
        const elements = Array.from(
          document.querySelectorAll<HTMLElement>(targetSelector),
        );

        const visibleElements = elements.filter(shouldTrackElement);

        // Enhanced debugging to show why elements might be filtered out
        console.debug("[Oneko] findVisibleElements", {
          targetSelector,
          viewport: { width: window.innerWidth, height: window.innerHeight },
          totalElements: elements.length,
          visibleElements: visibleElements.length,
          visibleTags: visibleElements.map(el => el.tagName),
          elementDetails: elements.map(el => {
            const rect = el.getBoundingClientRect();
            const style = window.getComputedStyle(el);
            return {
              tag: el.tagName,
              className: el.className,
              id: el.id,
              rect: {
                top: Math.round(rect.top),
                left: Math.round(rect.left),
                width: Math.round(rect.width),
                height: Math.round(rect.height),
              },
              visible: style.visibility !== "hidden",
              displayed: style.display !== "none",
              passesTopCheck: rect.top >= SPRITE_SIZE + SPRITE_TOP_MARGIN,
              passesViewportCheck: rect.top < window.innerHeight - SPRITE_SIZE,
              passesLeftCheck:
                rect.left >= 0 && rect.left < window.innerWidth - 100,
              isValid: shouldTrackElement(el),
            };
          }),
        });

        return visibleElements;
      };

      const selectTargetElement = (
        elements: HTMLElement[],
      ): HTMLElement | null => {
        if (elements.length === 0) return null;

        // Sort elements by height (tallest to shortest) to find the best perch
        const sortedElements = elements.sort((a, b) => {
          const rectA = a.getBoundingClientRect();
          const rectB = b.getBoundingClientRect();
          return rectB.height - rectA.height;
        });

        console.debug("[Oneko] selectTargetElement", {
          elementHeights: sortedElements.map(el => ({
            tag: el.tagName,
            height: Math.round(el.getBoundingClientRect().height),
          })),
          selected: sortedElements[0]?.tagName,
        });

        // Return the tallest element
        return sortedElements[0]!;
      };

      const getElementPosition = (element: HTMLElement): Position => {
        const rect = element.getBoundingClientRect();
        const halfSprite = SPRITE_SIZE / 2;

        // Random X position within element bounds with 20px margin
        const margin = 20;
        const minX = rect.left + margin;
        const maxX = rect.right - margin;
        const randomX = Math.random() * (maxX - minX) + minX;

        // Position cat on top of element, but ensure it stays within screen bounds
        const targetX = Math.min(
          Math.max(halfSprite, randomX),
          window.innerWidth - halfSprite,
        );
        const targetY = Math.max(halfSprite, rect.top - halfSprite) + 4; // Ensure Y doesn't go above screen bounds

        return {
          x: targetX,
          y: targetY,
        };
      };

      const updateTarget = (): void => {
        const visibleElements = findVisibleElements();
        const targetElement = selectTargetElement(visibleElements);

        console.debug("[Oneko] updateTarget called", {
          visibleElementsCount: visibleElements.length,
          currentTarget: state.targetElement?.tagName,
          newTarget: targetElement?.tagName,
          currentStatus: state.status,
        });

        if (targetElement) {
          // Don't retarget if we're already targeting the same element and are sitting or moving to it
          if (
            state.targetElement === targetElement &&
            (state.status === "sitting-on-target" ||
              state.status === "moving-to-target")
          ) {
            console.debug(
              "[Oneko] Skipping retarget - already targeting this element",
            );
            return;
          }

          const newPosition = getElementPosition(targetElement);

          // Validate the position has valid coordinates (but allow off-screen)
          if (isValidPosition(newPosition)) {
            console.debug("[Oneko] Setting new target", {
              element: targetElement.tagName,
              position: newPosition,
              previousTarget: state.targetElement?.tagName,
            });
            state.targetElement = targetElement;
            state.targetPosition = newPosition;
            state.status = "moving-to-target";
            state.idleTime = 0; // Reset idle time when finding new target
          }
        } else {
          // No elements found, move cat off-screen below the viewport
          console.debug("[Oneko] No target elements found, moving off-screen");
          state.targetElement = null;
          state.targetPosition = {
            x: window.innerWidth / 2,
            y: window.innerHeight + SPRITE_SIZE * 2, // Move well below the viewport
          };
          state.status = "off-screen";
          state.idleTime = 0; // Reset idle time when going off-screen
        }
      };

      let scrollTimeout: NodeJS.Timeout | null = null;
      let lastTargetUpdateTime = 0;

      const handleScroll = (): void => {
        // Debounce the retargeting logic - only find new element after scroll stops
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }

        scrollTimeout = setTimeout(() => {
          // Prevent rapid retargeting - wait at least 500ms between target updates
          const now = Date.now();
          if (now - lastTargetUpdateTime < 500) {
            console.debug("[Oneko] Scroll handler: rate limited, skipping");
            return;
          }

          console.debug("[Oneko] Scroll handler: calling updateTarget");
          lastTargetUpdateTime = now;
          updateTarget();
        }, 300); // Wait 300ms after scroll stops
      };

      // Initial target finding
      updateTarget();

      // Set up scroll listener to retarget when elements move
      document.addEventListener("scroll", handleScroll, { passive: true });
      window.addEventListener("resize", handleScroll, { passive: true });

      // Periodically check for new elements (in case of dynamic content)
      const retargetInterval = setInterval(() => {
        const now = Date.now();

        // Only retarget if we don't currently have a target AND respect rate limiting
        if (!state.targetElement && now - lastTargetUpdateTime >= 2000) {
          lastTargetUpdateTime = now;
          updateTarget();
        }
        // If we have a target but have been idle for a very long time, consider retargeting
        else if (
          state.targetElement &&
          state.idleTime > 300 &&
          now - lastTargetUpdateTime >= 5000
        ) {
          // Check if current target is still valid before retargeting
          if (!shouldTrackElement(state.targetElement)) {
            lastTargetUpdateTime = now;
            updateTarget();
          }
        }
      }, 3000); // Check every 3 seconds

      return () => {
        document.removeEventListener("scroll", handleScroll);
        window.removeEventListener("resize", handleScroll);
        clearInterval(retargetInterval);
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }
      };
    },
    [targetSelector],
  );

  useEffect(() => {
    // Don't start if user prefers reduced motion
    if (prefersReducedMotion()) {
      return;
    }

    // Wait for ref to be available
    const neko = nekoRef.current;
    if (!neko) {
      return;
    }

    // Start the cat off-screen at bottom center
    const bottomCenterX = window.innerWidth / 2;
    const bottomOffScreenY = window.innerHeight + SPRITE_SIZE * 2;

    const state: OnekoState = {
      element: neko,
      position: { x: bottomCenterX, y: bottomOffScreenY },
      targetPosition: { x: bottomCenterX, y: bottomOffScreenY }, // Will be updated by setupElementTracking
      targetElement: null,
      status: "off-screen",
      frameCount: 0,
      idleTime: 0,
      idleAnimation: null,
      idleAnimationFrame: 0,
      isRunning: true,
    };

    stateRef.current = state;

    // Set initial position
    updateNekoPosition(state);

    // Set up element tracking (this will find initial target)
    const cleanupElementTracking = setupElementTracking(state);

    // Start animation loop
    startAnimation(state);

    // Return cleanup function
    return () => {
      state.isRunning = false;
      cleanupElementTracking();
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [setupElementTracking, startAnimation]);

  // Don't render if user prefers reduced motion
  if (prefersReducedMotion()) {
    return null;
  }

  return (
    <Box
      ref={nekoRef}
      className={classes.neko}
      w={SPRITE_SIZE}
      h={SPRITE_SIZE}
      top={SPRITE_SIZE / 2}
      left={SPRITE_SIZE / 2}
      style={{
        width: `${SPRITE_SIZE}px`,
        height: `${SPRITE_SIZE}px`,
        zIndex: MAX_Z_INDEX,
        backgroundImage: `url(${onekoSpriteSrc})`,
      }}
      aria-hidden="true"
    />
  );
};

export default Oneko;

/**
 * Check if the user prefers reduced motion
 */
const prefersReducedMotion = (): boolean => {
  const { matches } = matchMedia("(prefers-reduced-motion: reduce)");
  return matches;
};

/**
 * Set the sprite position for the neko element
 */
const setSprite = (
  state: OnekoState,
  animationName: keyof SpriteSets,
  frame: number,
): void => {
  const animation = SPRITE_SETS[animationName];
  if (!animation || animation.length === 0) return;

  const sprite = animation[frame % animation.length]!;
  const bgPosX = sprite.x * SPRITE_SIZE;
  const bgPosY = sprite.y * SPRITE_SIZE;

  state.element.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
};

/**
 * Update the neko element position on screen
 */
const updateNekoPosition = (state: OnekoState): void => {
  const left = state.position.x - SPRITE_SIZE / 2;
  const top = state.position.y - SPRITE_SIZE / 2;

  state.element.style.left = `${left}px`;
  state.element.style.top = `${top}px`;
};

/**
 * Reset idle animation state
 */
const resetIdleAnimation = (state: OnekoState): void => {
  state.idleAnimation = null;
  state.idleAnimationFrame = 0;
};

/**
 * Get available idle animations based on neko position
 */
const getAvailableIdleAnimations = (state: OnekoState): IdleAnimationType[] => {
  const animations: IdleAnimationType[] = ["sleeping", "scratchSelf"];

  if (state.position.x < SPRITE_SIZE) {
    animations.push("scratchWallW");
  }
  if (state.position.y < SPRITE_SIZE) {
    animations.push("scratchWallN");
  }
  if (state.position.x > innerWidth - SPRITE_SIZE) {
    animations.push("scratchWallE");
  }
  if (state.position.y > innerHeight - SPRITE_SIZE) {
    animations.push("scratchWallS");
  }

  return animations;
};

/**
 * Handle a single animation frame, which is now the state machine
 */
const handleAnimationFrame = (state: OnekoState, speed: number): void => {
  state.frameCount += 1;

  // Validate target position before attempting to move (only check for invalid values, allow off-screen)
  if (!isValidPosition(state.targetPosition)) {
    console.debug(
      "[Oneko] Invalid target position detected, resetting to off-screen",
    );
    // Invalid target position, reset to off-screen bottom center
    state.targetPosition = {
      x: window.innerWidth / 2,
      y: window.innerHeight + SPRITE_SIZE * 2,
    };
    state.targetElement = null;
    state.status = "off-screen";
  }

  const diffX = state.position.x - state.targetPosition.x;
  const diffY = state.position.y - state.targetPosition.y;
  const distance = Math.sqrt(diffX ** 2 + diffY ** 2);

  // Only log every 60 frames to avoid spam
  if (state.frameCount % 60 === 0) {
    console.debug("[Oneko] Animation frame", {
      status: state.status,
      position: state.position,
      targetPosition: state.targetPosition,
      distance: Math.round(distance),
      targetElement: state.targetElement?.tagName,
    });
  }

  // --- STATE MACHINE ---
  switch (state.status) {
    case "off-screen": {
      // If the cat is not at its off-screen target position, move it there
      if (distance > 1) {
        const direction = getMovementDirection(diffX, diffY, distance);
        setSprite(state, direction, state.frameCount);
        const newX = state.position.x - (diffX / distance) * speed;
        const newY = state.position.y - (diffY / distance) * speed;
        state.position = { x: newX, y: newY }; // Do not constrain while moving off-screen
        updateNekoPosition(state);
      }
      break;
    }

    case "moving-to-target": {
      // If close to target, transition to sitting
      const arrivalThreshold = Math.min(speed * 0.5, 8);
      if (distance < arrivalThreshold) {
        state.position = { ...state.targetPosition };
        updateNekoPosition(state);
        state.status = "sitting-on-target";
        state.idleTime = 0;
        state.idleAnimation = null;
        state.idleAnimationFrame = 0;
        return;
      }

      // Reset idle state when starting to move
      state.idleAnimation = null;
      state.idleAnimationFrame = 0;

      // Show alert before moving if was idle
      if (state.idleTime > 1) {
        setSprite(state, "alert", 0);
        state.idleTime = Math.min(state.idleTime, 7);
        state.idleTime -= 1;
        return;
      }

      // Move toward target
      const direction = getMovementDirection(diffX, diffY, distance);
      setSprite(state, direction, state.frameCount);
      const newX = state.position.x - (diffX / distance) * speed;
      const newY = state.position.y - (diffY / distance) * speed;
      state.position = constrainPosition(newX, newY);
      updateNekoPosition(state);
      break;
    }

    case "sitting-on-target": {
      state.idleTime += 1;
      setSprite(state, "idle", 0);

      // After a while, decide to perform a random idle animation
      const animationThreshold = 150;
      if (
        state.idleTime > 10 &&
        Math.floor(Math.random() * animationThreshold) === 0
      ) {
        const availableAnimations = getAvailableIdleAnimations(state);
        const randomIndex = Math.floor(
          Math.random() * availableAnimations.length,
        );
        state.idleAnimation = availableAnimations[randomIndex]!;
        state.idleAnimationFrame = 0;
        state.status = "performing-idle-animation";
      }
      break;
    }

    case "performing-idle-animation": {
      state.idleAnimationFrame += 1;
      const { idleAnimation, idleAnimationFrame } = state;

      if (!idleAnimation) {
        state.status = "sitting-on-target";
        break;
      }

      // Handle the two types of idle animations: long (sleeping) and short (scratching)
      if (idleAnimation === "sleeping") {
        if (idleAnimationFrame < 8) {
          setSprite(state, "tired", 0);
        } else {
          setSprite(state, "sleeping", Math.floor(idleAnimationFrame / 4));
        }
        if (idleAnimationFrame > 192) {
          resetIdleAnimation(state);
          state.status = "sitting-on-target";
        }
      } else {
        // All other animations are short, 9-frame animations
        setSprite(state, idleAnimation, idleAnimationFrame);
        if (idleAnimationFrame > 9) {
          resetIdleAnimation(state);
          state.status = "sitting-on-target";
        }
      }
      break;
    }
  }
};

/**
 * Calculate movement direction based on mouse position
 */
const getMovementDirection = (
  diffX: number,
  diffY: number,
  distance: number,
): keyof SpriteSets => {
  if (distance < 1) return "idle";
  const normY = diffY / distance;
  const normX = diffX / distance;
  const dirY = normY > 0.5 ? "N" : normY < -0.5 ? "S" : "";
  const dirX = normX > 0.5 ? "W" : normX < -0.5 ? "E" : "";
  return (dirY + dirX || "idle") as keyof SpriteSets;
};

/**
 * Constrain position within window bounds
 */
const constrainPosition = (x: number, y: number): Position => {
  const halfSprite = SPRITE_SIZE / 2;
  return {
    x: Math.min(Math.max(halfSprite, x), innerWidth - halfSprite),
    y: Math.min(Math.max(halfSprite, y), innerHeight - halfSprite),
  };
};

/**
 * Check if a position has valid coordinates
 */
const isValidPosition = (position: Position): boolean => {
  return isFinite(position.x) && isFinite(position.y);
};

/**
 * Check if an element should be tracked by the cat
 */
const shouldTrackElement = (element: HTMLElement): boolean => {
  const rect = element.getBoundingClientRect();
  const style = window.getComputedStyle(element);

  return (
    rect.width > 0 &&
    rect.height > 0 &&
    rect.top >= SPRITE_SIZE + SPRITE_TOP_MARGIN && // Ensure enough clearance from top for cat
    rect.top < window.innerHeight - SPRITE_SIZE && // Ensure element is visible in viewport
    rect.left >= 0 &&
    rect.left < window.innerWidth - 100 &&
    style.visibility !== "hidden" &&
    style.display !== "none"
  );
};
