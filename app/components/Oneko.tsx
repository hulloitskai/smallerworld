/**
 * Generated by: Claude Sonnet 4
 * Last modified: 2025-01-27 22:30:00 UTC
 *
 * This code was AI-generated and may require human review and testing.
 */

/**
 * Oneko - A cat that follows the mouse cursor
 * Adapted from: https://github.com/adryd325/oneko.js
 */

import onekoSpriteSrc from "~/assets/images/oneko.gif";

import classes from "./Oneko.module.css";

interface Position {
  x: number;
  y: number;
}

interface SpriteCoordinate {
  x: number;
  y: number;
}

type SpriteAnimation = SpriteCoordinate[];

interface SpriteSets {
  idle: SpriteAnimation;
  alert: SpriteAnimation;
  scratchSelf: SpriteAnimation;
  scratchWallN: SpriteAnimation;
  scratchWallS: SpriteAnimation;
  scratchWallE: SpriteAnimation;
  scratchWallW: SpriteAnimation;
  tired: SpriteAnimation;
  sleeping: SpriteAnimation;
  N: SpriteAnimation;
  NE: SpriteAnimation;
  E: SpriteAnimation;
  SE: SpriteAnimation;
  S: SpriteAnimation;
  SW: SpriteAnimation;
  W: SpriteAnimation;
  NW: SpriteAnimation;
}

type IdleAnimationType =
  | "sleeping"
  | "scratchSelf"
  | "scratchWallN"
  | "scratchWallS"
  | "scratchWallE"
  | "scratchWallW"
  | null;

interface OnekoState {
  element: HTMLDivElement;
  position: Position;
  targetPosition: Position;
  targetElement: HTMLElement | null;
  frameCount: number;
  idleTime: number;
  idleAnimation: IdleAnimationType;
  idleAnimationFrame: number;
  lastFrameTimestamp?: number;
  isRunning: boolean;
}

const SPRITE_SIZE = 32;
const ANIMATION_INTERVAL = 100; // milliseconds
const MAX_Z_INDEX = 2147483647;
const SPRITE_SETS: SpriteSets = {
  idle: [{ x: -3, y: -3 }],
  alert: [{ x: -7, y: -3 }],
  scratchSelf: [
    { x: -5, y: 0 },
    { x: -6, y: 0 },
    { x: -7, y: 0 },
  ],
  scratchWallN: [
    { x: 0, y: 0 },
    { x: 0, y: -1 },
  ],
  scratchWallS: [
    { x: -7, y: -1 },
    { x: -6, y: -2 },
  ],
  scratchWallE: [
    { x: -2, y: -2 },
    { x: -2, y: -3 },
  ],
  scratchWallW: [
    { x: -4, y: 0 },
    { x: -4, y: -1 },
  ],
  tired: [{ x: -3, y: -2 }],
  sleeping: [
    { x: -2, y: 0 },
    { x: -2, y: -1 },
  ],
  N: [
    { x: -1, y: -2 },
    { x: -1, y: -3 },
  ],
  NE: [
    { x: 0, y: -2 },
    { x: 0, y: -3 },
  ],
  E: [
    { x: -3, y: 0 },
    { x: -3, y: -1 },
  ],
  SE: [
    { x: -5, y: -1 },
    { x: -5, y: -2 },
  ],
  S: [
    { x: -6, y: -3 },
    { x: -7, y: -2 },
  ],
  SW: [
    { x: -5, y: -3 },
    { x: -6, y: -1 },
  ],
  W: [
    { x: -4, y: -2 },
    { x: -4, y: -3 },
  ],
  NW: [
    { x: -1, y: 0 },
    { x: -1, y: -1 },
  ],
};

export interface OnekoProps {
  /** Speed of the cat movement (default: 10) */
  speed?: number;
  /** CSS selector for elements to target (e.g., 'button', '.my-class', '[data-perch]') */
  targetSelector: string;
}

/**
 * Oneko component that renders a cat that finds and sits on specified elements
 */
const Oneko: FC<OnekoProps> = ({ speed = 10, targetSelector }) => {
  const animationFrameRef = useRef<number>();
  const stateRef = useRef<OnekoState>();
  const nekoRef = useRef<HTMLDivElement>(null);

  const startAnimation = useCallback(
    (state: OnekoState) => {
      const onAnimationFrame = (timestamp: number): void => {
        // Stop if element is removed from DOM or component unmounted
        if (!state.element.isConnected || !state.isRunning) {
          return;
        }

        if (!state.lastFrameTimestamp) {
          state.lastFrameTimestamp = timestamp;
        }

        // Limit to ~10 FPS
        if (timestamp - state.lastFrameTimestamp > ANIMATION_INTERVAL) {
          state.lastFrameTimestamp = timestamp;
          handleAnimationFrame(state, speed);
        }

        animationFrameRef.current = requestAnimationFrame(onAnimationFrame);
      };

      animationFrameRef.current = requestAnimationFrame(onAnimationFrame);
    },
    [speed],
  );

  const setupElementTracking = useCallback(
    (state: OnekoState) => {
      const findVisibleElements = (): HTMLElement[] => {
        const elements = Array.from(
          document.querySelectorAll<HTMLElement>(targetSelector),
        );

        const viewportHeight = window.innerHeight;
        const viewportWidth = window.innerWidth;

        return elements.filter(element => {
          const rect = element.getBoundingClientRect();
          const conditions = {
            hasWidth: rect.width > 0,
            hasHeight: rect.height > 0,
            // Check for partial visibility instead of requiring entire element to be in bounds
            isPartiallyVisible:
              rect.bottom > 0 && // Element extends into viewport from top
              rect.top < viewportHeight && // Element starts before viewport bottom
              rect.right > 0 && // Element extends into viewport from left
              rect.left < viewportWidth, // Element starts before viewport right
            hasSpaceAbove: rect.top >= SPRITE_SIZE + 20, // Ensure enough space for cat to sit on top
            isVisible: window.getComputedStyle(element).visibility !== "hidden",
            isDisplayed: window.getComputedStyle(element).display !== "none",
          };

          return Object.values(conditions).every(Boolean);
        });
      };

      const selectTargetElement = (
        elements: HTMLElement[],
      ): HTMLElement | null => {
        // Simply return the first matching element
        return elements.length > 0 ? elements[0]! : null;
      };

      const getElementPosition = (element: HTMLElement): Position => {
        const rect = element.getBoundingClientRect();
        const halfSprite = SPRITE_SIZE / 2;

        // Random X position within element bounds with 20px margin
        const margin = 20;
        const minX = rect.left + margin;
        const maxX = rect.right - margin;
        const randomX = Math.random() * (maxX - minX) + minX;

        // Position cat on top of element, but ensure it stays within screen bounds
        const targetX = Math.min(
          Math.max(halfSprite, randomX),
          window.innerWidth - halfSprite,
        );
        const targetY = Math.max(halfSprite, rect.top - halfSprite) + 4; // Ensure Y doesn't go above screen bounds

        return {
          x: targetX,
          y: targetY,
        };
      };

      const updateTarget = (): void => {
        const visibleElements = findVisibleElements();
        const targetElement = selectTargetElement(visibleElements);

        if (targetElement) {
          state.targetElement = targetElement;
          state.targetPosition = getElementPosition(targetElement);
        } else {
          // No elements found, stay in current position
          state.targetElement = null;
          state.targetPosition = { ...state.position };
        }
      };

      let scrollTimeout: NodeJS.Timeout | null = null;

      const handleScroll = (): void => {
        // Debounce the retargeting logic - only find new element after scroll stops
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }

        scrollTimeout = setTimeout(() => {
          if (state.targetElement) {
            const rect = state.targetElement.getBoundingClientRect();
            const isStillVisible =
              rect.top >= -50 &&
              rect.left >= -50 &&
              rect.bottom <= window.innerHeight + 50 &&
              rect.right <= window.innerWidth + 50;

            if (isStillVisible) {
              // Update to current position of the same element
              state.targetPosition = getElementPosition(state.targetElement);
            } else {
              // Current element is out of view, find a new one
              updateTarget();
            }
          } else {
            // No current target, try to find one
            updateTarget();
          }
        }, 300); // Wait 300ms after scroll stops
      };

      // Initial target finding
      updateTarget();

      // Set up scroll listener to retarget when elements move
      document.addEventListener("scroll", handleScroll, { passive: true });
      window.addEventListener("resize", handleScroll, { passive: true });

      // Periodically check for new elements (in case of dynamic content)
      const retargetInterval = setInterval(() => {
        // Only retarget if we don't currently have a target or if we've been idle for a while
        if (!state.targetElement || state.idleTime > 100) {
          updateTarget();
        }
      }, 3000); // Check every 3 seconds

      return () => {
        document.removeEventListener("scroll", handleScroll);
        window.removeEventListener("resize", handleScroll);
        clearInterval(retargetInterval);
        if (scrollTimeout) {
          clearTimeout(scrollTimeout);
        }
      };
    },
    [targetSelector],
  );

  useEffect(() => {
    // Don't start if user prefers reduced motion
    if (prefersReducedMotion()) {
      return;
    }

    // Wait for ref to be available
    const neko = nekoRef.current;
    if (!neko) {
      return;
    }

    const state: OnekoState = {
      element: neko,
      position: { x: SPRITE_SIZE, y: SPRITE_SIZE },
      targetPosition: { x: SPRITE_SIZE, y: SPRITE_SIZE }, // Will be updated by setupElementTracking
      targetElement: null,
      frameCount: 0,
      idleTime: 0,
      idleAnimation: null,
      idleAnimationFrame: 0,
      isRunning: true,
    };

    stateRef.current = state;

    // Set initial position
    updateNekoPosition(state);

    // Set up element tracking (this will find initial target)
    const cleanupElementTracking = setupElementTracking(state);

    // Start animation loop
    startAnimation(state);

    // Return cleanup function
    return () => {
      state.isRunning = false;
      cleanupElementTracking();
      if (animationFrameRef.current) {
        cancelAnimationFrame(animationFrameRef.current);
      }
    };
  }, [setupElementTracking, startAnimation]);

  // Don't render if user prefers reduced motion
  if (prefersReducedMotion()) {
    return null;
  }

  return (
    <Box
      ref={nekoRef}
      className={classes.neko}
      w={SPRITE_SIZE}
      h={SPRITE_SIZE}
      top={SPRITE_SIZE / 2}
      left={SPRITE_SIZE / 2}
      style={{
        width: `${SPRITE_SIZE}px`,
        height: `${SPRITE_SIZE}px`,
        zIndex: MAX_Z_INDEX,
        backgroundImage: `url(${onekoSpriteSrc})`,
      }}
      aria-hidden="true"
    />
  );
};

export default Oneko;

/**
 * Check if the user prefers reduced motion
 */
const prefersReducedMotion = (): boolean => {
  const { matches } = matchMedia("(prefers-reduced-motion: reduce)");
  return matches;
};

/**
 * Set the sprite position for the neko element
 */
const setSprite = (
  state: OnekoState,
  animationName: keyof SpriteSets,
  frame: number,
): void => {
  const animation = SPRITE_SETS[animationName];
  if (!animation || animation.length === 0) return;

  const sprite = animation[frame % animation.length]!;
  const bgPosX = sprite.x * SPRITE_SIZE;
  const bgPosY = sprite.y * SPRITE_SIZE;

  state.element.style.backgroundPosition = `${bgPosX}px ${bgPosY}px`;
};

/**
 * Update the neko element position on screen
 */
const updateNekoPosition = (state: OnekoState): void => {
  const left = state.position.x - SPRITE_SIZE / 2;
  const top = state.position.y - SPRITE_SIZE / 2;

  state.element.style.left = `${left}px`;
  state.element.style.top = `${top}px`;
};

/**
 * Reset idle animation state
 */
const resetIdleAnimation = (state: OnekoState): void => {
  state.idleAnimation = null;
  state.idleAnimationFrame = 0;
};

/**
 * Get available idle animations based on neko position
 */
const getAvailableIdleAnimations = (state: OnekoState): IdleAnimationType[] => {
  const animations: IdleAnimationType[] = ["sleeping", "scratchSelf"];

  if (state.position.x < SPRITE_SIZE) {
    animations.push("scratchWallW");
  }
  if (state.position.y < SPRITE_SIZE) {
    animations.push("scratchWallN");
  }
  if (state.position.x > innerWidth - SPRITE_SIZE) {
    animations.push("scratchWallE");
  }
  if (state.position.y > innerHeight - SPRITE_SIZE) {
    animations.push("scratchWallS");
  }

  return animations;
};

/**
 * Handle idle behavior and animations when sitting on an element
 */
const handleIdle = (state: OnekoState): void => {
  state.idleTime += 1;

  // Start random idle animation every ~20 seconds, or sooner if sitting on an element
  const animationThreshold = state.targetElement ? 150 : 200; // Slightly more active when on an element
  if (
    state.idleTime > 10 &&
    Math.floor(Math.random() * animationThreshold) === 0 &&
    state.idleAnimation === null
  ) {
    const availableAnimations = getAvailableIdleAnimations(state);
    const randomIndex = Math.floor(Math.random() * availableAnimations.length);
    state.idleAnimation = availableAnimations[randomIndex]!;
  }

  switch (state.idleAnimation) {
    case "sleeping":
      if (state.idleAnimationFrame < 8) {
        setSprite(state, "tired", 0);
        break;
      }
      setSprite(state, "sleeping", Math.floor(state.idleAnimationFrame / 4));
      if (state.idleAnimationFrame > 192) {
        resetIdleAnimation(state);
      }
      break;

    case "scratchWallN":
    case "scratchWallS":
    case "scratchWallE":
    case "scratchWallW":
    case "scratchSelf":
      setSprite(state, state.idleAnimation, state.idleAnimationFrame);
      if (state.idleAnimationFrame > 9) {
        resetIdleAnimation(state);
      }
      break;

    default:
      setSprite(state, "idle", 0);
      return;
  }

  state.idleAnimationFrame += 1;
};

/**
 * Calculate movement direction based on mouse position
 */
const getMovementDirection = (
  diffX: number,
  diffY: number,
  distance: number,
): keyof SpriteSets => {
  let direction = "";

  if (diffY / distance > 0.5) direction += "N";
  if (diffY / distance < -0.5) direction += "S";
  if (diffX / distance > 0.5) direction += "W";
  if (diffX / distance < -0.5) direction += "E";

  return (direction || "idle") as keyof SpriteSets;
};

/**
 * Constrain position within window bounds
 */
const constrainPosition = (x: number, y: number): Position => {
  const halfSprite = SPRITE_SIZE / 2;
  return {
    x: Math.min(Math.max(halfSprite, x), innerWidth - halfSprite),
    y: Math.min(Math.max(halfSprite, y), innerHeight - halfSprite),
  };
};

/**
 * Handle a single animation frame
 */
const handleAnimationFrame = (state: OnekoState, speed: number): void => {
  state.frameCount += 1;

  const diffX = state.position.x - state.targetPosition.x;
  const diffY = state.position.y - state.targetPosition.y;
  const distance = Math.sqrt(diffX ** 2 + diffY ** 2);

  // If close to target, enter idle state - use smaller threshold for better element positioning
  const arrivalThreshold = Math.min(speed * 0.5, 8); // Much tighter threshold for sitting on elements
  if (distance < arrivalThreshold) {
    // Snap to exact target position when close enough
    state.position.x = state.targetPosition.x;
    state.position.y = state.targetPosition.y;
    updateNekoPosition(state);
    handleIdle(state);
    return;
  }

  // Reset idle state when starting to move
  state.idleAnimation = null;
  state.idleAnimationFrame = 0;

  // Show alert before moving if was idle
  if (state.idleTime > 1) {
    setSprite(state, "alert", 0);
    state.idleTime = Math.min(state.idleTime, 7);
    state.idleTime -= 1;
    return;
  }

  // Move toward target
  const direction = getMovementDirection(diffX, diffY, distance);
  setSprite(state, direction, state.frameCount);

  const newX = state.position.x - (diffX / distance) * speed;
  const newY = state.position.y - (diffY / distance) * speed;

  state.position = constrainPosition(newX, newY);
  updateNekoPosition(state);
};
