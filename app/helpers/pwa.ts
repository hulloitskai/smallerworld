/**
 * Generated by: Claude Sonnet 4
 * Last modified: 2024-12-19 15:30:00 UTC
 *
 * This code was AI-generated and may require human review and testing.
 */

import { useDocumentVisibility } from "@mantine/hooks";
import { createContext, useContext } from "react";

import { type PageCSRF } from "~/types";

import { queryParamsFromPath } from "./inertia/routing";
import { resetSWRCache } from "./routes/swr";

export interface PWAState {
  freshCSRF: { param: string; token: string } | null;
  activeServiceWorker: ServiceWorker | null | undefined;
  isStandalone: boolean | undefined;
  outOfPWAScope: boolean;
  installing: boolean;
  install: (() => Promise<void>) | null | undefined;
  installError: Error | undefined;
}

export const PWAContext = createContext<PWAState | undefined>(undefined);

export const usePWA = (): PWAState => {
  const context = useContext(PWAContext);
  if (!context) {
    throw new Error("usePWA must be used within a PWAProvider");
  }
  return context;
};

export const useIsStandalone = (): boolean | undefined => {
  const [isStandalone, setIsStandalone] = useState<boolean | undefined>(
    undefined,
  );
  useEffect(() => {
    if (isStandalone !== undefined) {
      return;
    }
    const mediaMatch = matchMedia("(display-mode: standalone)");
    setIsStandalone(mediaMatch.matches);
    const listener = (event: MediaQueryListEvent): void => {
      setIsStandalone(event.matches);
    };
    mediaMatch.addEventListener("change", listener);
    return () => {
      mediaMatch.removeEventListener("change", listener);
    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps
  return isStandalone;
};

export const useOutOfPWAScope = (): boolean => {
  const { url } = usePage();
  return useMemo(() => {
    const { pwa_scope: pwaScope } = queryParamsFromPath(url);
    const expectedScope = getPWAScope();
    
    // If we have a PWA scope in the URL but it doesn't match the expected scope,
    // or if we're in standalone mode but don't have a PWA scope at all
    if (pwaScope && expectedScope && pwaScope !== expectedScope) {
      return true;
    }
    
    // If we're in standalone mode but don't have a PWA scope in the URL
    if (expectedScope && !pwaScope) {
      return true;
    }
    
    return false;
  }, [url]);
};

export const getPWAScope = (): string | null => getMeta("pwa-scope") ?? null;

const useInstallPromptEvent = ():
  | BeforeInstallPromptEvent
  | undefined
  | null => {
  const [event, setEvent] = useState<
    BeforeInstallPromptEvent | undefined | null
  >();
  useEffect(() => {
    const capturedEvent = window.installPromptEvent;
    setEvent(capturedEvent ?? null);
    const listener = (event: Event) => {
      event.preventDefault();
      setEvent(event as BeforeInstallPromptEvent);
    };
    addEventListener("beforeinstallprompt", listener);
    return () => {
      removeEventListener("beforeinstallprompt", listener);
    };
  }, []);
  return event;
};

export interface InstallPWAResult {
  installing: boolean;
  install: (() => Promise<void>) | null | undefined;
  error: Error | undefined;
}

export const useInstallPWA = (): InstallPWAResult => {
  const installPromptEvent = useInstallPromptEvent();
  const [installing, setInstalling] = useState(false);
  const [error, setError] = useState<Error | undefined>();
  const install = useMemo<(() => Promise<void>) | null | undefined>(() => {
    if (installPromptEvent) {
      return () => {
        console.info("Installing PWA");
        setInstalling(true);
        return installPromptEvent
          .prompt()
          .then(
            () => {
              console.info("PWA installation triggered");
              toast.success("app installation started");
            },
            error => {
              console.error("Failed to install PWA", error);
              if (error instanceof Error) {
                setError(error);
                toast.error("failed to install app", {
                  description: error.message,
                });
              }
            },
          )
          .finally(() => {
            setInstalling(false);
          });
      };
    }
    return installPromptEvent;
  }, [installPromptEvent]);
  return {
    installing,
    install,
    error,
  };
};

export const useFreshCSRF = (): PageCSRF | null => {
  const pageProps = usePageProps();
  const [freshCSRF, setFreshCSRF] = useState<PageCSRF | null>(
    () => pageProps.csrf,
  );
  const visibility = useDocumentVisibility();
  useDidUpdate(() => {
    if (visibility === "hidden") {
      setFreshCSRF(null);
    } else if (visibility === "visible") {
      router.reload({
        only: ["csrf"],
        async: true,
        onBefore: () => {
          setFreshCSRF(null);
        },
        onSuccess: ({ props }) => {
          const { csrf } = props as unknown as SharedPageProps;
          setFreshCSRF(csrf);
          void resetSWRCache();
        },
      });
    }
  }, [visibility]);
  return freshCSRF;
};
